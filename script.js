document.addEventListener("DOMContentLoaded", () => {
  const screenSaver = document.getElementById("screenSaver");
  const dvdLogo = document.getElementById("dvdLogo");

  // --- 이미지 목록 생성 ---
  // 1. 수동으로 추가할 이미지 목록
  const manualFiles = [
    // 여기에 규칙 없는 파일 추가. 예: 'img/special.gif'
  ];

  // 2. 규칙적인 이름의 이미지를 자동으로 생성
  const imagePath = "img/";
  const baseName = "psy_pudding_still_";
  const extension = ".png";
  const startNumber = 100; // 시작 번호
  const endNumber = 165;   // 끝 번호
  
  const totalImages = endNumber - startNumber + 1;

  const autoGeneratedFiles = [];
  for (let i = 0; i < totalImages; i++) {
    const fileNumber = startNumber + i;
    const fileName = `${imagePath}${baseName}${fileNumber}${extension}`;
    autoGeneratedFiles.push(fileName);
  }

  // 3. 두 배열을 합쳐 최종 이미지 목록을 완성
  const imageFiles = [...manualFiles, ...autoGeneratedFiles];

  // --- 변수 선언 및 초기화 ---
  let imageObjects = []; // {src, bounds} 객체를 담을 배열
  let currentImageIndex = 0;
  let x = 0;
  let y = 0;
  let dx = 2; // X축 이동 속도 (픽셀)
  let dy = 2; // Y축 이동 속도 (픽셀)
  let logoWidth;
  let logoHeight;
  let screenWidth;
  let screenHeight;

  let animationStarted = false; // 애니메이션 중복 실행 방지 플래그

  // 충돌 후 이미지 변경을 제어하기 위한 변수
  let canChangeImage = true; // 이미지 변경 가능 여부 플래그
  const imageChangeCooldown = 250; // 이미지 변경 쿨다운 시간 (0.25초)

  /**
   * 이미지의 실제 콘텐츠 영역(투명 픽셀 제외)을 분석합니다.
   * @param {string} src - 분석할 이미지의 경로
   * @returns {Promise<object>} - { minX, minY, width, height } 형태의 경계 정보 객체를 반환하는 프로미스
   */
  function analyzeImageBounds(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = src;

      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        try {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
          let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;

          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              const alpha = imageData[(y * canvas.width + x) * 4 + 3];
              if (alpha > 0) {
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
              }
            }
          }

          if (maxX > -1) {
            resolve({ minX, minY, width: maxX - minX + 1, height: maxY - minY + 1 });
          } else {
            resolve({ minX: 0, minY: 0, width: 0, height: 0 }); // 완전히 투명한 이미지
          }
        } catch (e) {
          console.error(`이미지 분석 실패(CORS 정책 위반 가능성): ${src}`, e);
          // 실패 시 전체 영역을 경계로 사용
          resolve({ minX: 0, minY: 0, width: img.width, height: img.height });
        }
      };
      
      img.onerror = () => reject(new Error(`이미지 로드 실패: ${src}`));
    });
  }

  // --- 초기 설정 함수 (비동기 처리) ---
  async function initializeScreenSaver() {
    if (imageFiles.length === 0) {
      console.error("이미지 파일 목록이 비어있습니다. 스크린세이버를 시작할 수 없습니다.");
      dvdLogo.style.display = 'none';
      return;
    }

    try {
      console.log("이미지 경계 분석을 시작합니다... (잠시 기다려주세요)");
      const analysisPromises = imageFiles.map(src => 
        analyzeImageBounds(src).then(bounds => ({ src, bounds }))
      );
      imageObjects = await Promise.all(analysisPromises);
      console.log("모든 이미지 분석 완료!");
    } catch (error) {
        console.error("이미지 분석 중 심각한 오류 발생:", error);
        dvdLogo.style.display = 'none';
        return;
    }

    resizeLogo();
    updateScreenDimensions();

    x = Math.random() * (screenWidth - logoWidth);
    y = Math.random() * (screenHeight - logoHeight);
    dvdLogo.style.transform = `translate(${x}px, ${y}px)`;

    currentImageIndex = Math.floor(Math.random() * imageObjects.length);
    dvdLogo.src = imageObjects[currentImageIndex].src;

    if (!animationStarted) {
      requestAnimationFrame(animate);
      animationStarted = true;
    }
  }

  // --- 이미지 크기 조절 함수 ---
  function resizeLogo() {
    const dynamicWidth = window.innerWidth * 0.15;
    const dynamicHeight = window.innerHeight * 0.2;
    dvdLogo.style.width = `${dynamicWidth}px`;
    dvdLogo.style.height = `${dynamicHeight}px`;
    logoWidth = dvdLogo.offsetWidth;
    logoHeight = dvdLogo.offsetHeight;
  }

  // --- 화면 크기 업데이트 함수 ---
  function updateScreenDimensions() {
    screenWidth = screenSaver.offsetWidth;
    screenHeight = screenSaver.offsetHeight;
  }

  // --- 애니메이션 루프 ---
  function animate() {
    updateScreenDimensions();

    x += dx;
    y += dy;

    // 현재 이미지의 실제 콘텐츠 경계 정보 가져오기
    const currentImage = imageObjects[currentImageIndex];
    // naturalWidth가 0인 경우(이미지 로드 전) 오류 방지
    const naturalWidth = dvdLogo.naturalWidth || logoWidth;
    const naturalHeight = dvdLogo.naturalHeight || logoHeight;
    const bounds = currentImage.bounds;

    // 실제 콘텐츠의 화면상 위치 계산
    const scaleX = logoWidth / naturalWidth;
    const scaleY = logoHeight / naturalHeight;

    const visualLeft = x + (bounds.minX * scaleX);
    const visualRight = x + ((bounds.minX + bounds.width) * scaleX);
    const visualTop = y + (bounds.minY * scaleY);
    const visualBottom = y + ((bounds.minY + bounds.height) * scaleY);

    let hit = false; // 충돌 여부 플래그

    // X축 경계 충돌 검사
    if (visualRight >= screenWidth) {
      x = screenWidth - ((bounds.minX + bounds.width) * scaleX);
      dx *= -1;
      hit = true;
    } else if (visualLeft <= 0) {
      x = -(bounds.minX * scaleX);
      dx *= -1;
      hit = true;
    }

    // Y축 경계 충돌 검사
    if (visualBottom >= screenHeight) {
      y = screenHeight - ((bounds.minY + bounds.height) * scaleY);
      dy *= -1;
      hit = true;
    } else if (visualTop <= 0) {
      y = -(bounds.minY * scaleY);
      dy *= -1;
      hit = true;
    }
    
    // 충돌이 발생하고, 이미지 변경이 가능한 상태일 때만 변경 로직 실행
    if (hit && canChangeImage) {
      changeImageWithCooldown();
    }

    dvdLogo.style.transform = `translate(${x}px, ${y}px)`;
    requestAnimationFrame(animate);
  }

  // --- 이미지 변경 및 쿨다운 적용 함수 ---
  function changeImageWithCooldown() {
    // 1. 이미지 변경을 막고, 다음 이미지를 준비
    canChangeImage = false;
    currentImageIndex = (currentImageIndex + 1) % imageObjects.length;
    dvdLogo.src = imageObjects[currentImageIndex].src;

    // 2. 일정 시간 후 다시 이미지 변경이 가능하도록 플래그를 복원
    setTimeout(() => {
      canChangeImage = true;
    }, imageChangeCooldown);
  }

  // --- 윈도우 크기 변경 이벤트 ---
  window.addEventListener("resize", () => {
    resizeLogo();
    updateScreenDimensions();
    // 창 크기 변경 시 로고가 밖으로 나가지 않도록 위치 보정
    x = Math.max(0, Math.min(x, screenWidth - logoWidth));
    y = Math.max(0, Math.min(y, screenHeight - logoHeight));
    dvdLogo.style.transform = `translate(${x}px, ${y}px)`;
  });

  // --- 스크린 세이버 시작 ---
  initializeScreenSaver();
});