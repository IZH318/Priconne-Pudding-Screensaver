document.addEventListener("DOMContentLoaded", () => {
  // --- DOM 요소 가져오기 ---
  const screenSaver = document.getElementById("screenSaver");
  const dvdLogo = document.getElementById("dvdLogo");

  // --- 이미지 목록 생성 ---
  // 1. 수동으로 추가할 파일 목록
  const manualFiles = [
    // 여기에 규칙 없는 파일 추가. 예: 'img/special.gif'
  ];

  // 2. 자동으로 생성할 파일 목록 정보
  const imagePath = "img/";
  const baseName = "psy_pudding_still_";
  const extension = ".png";
  const startNumber = 100;
  const endNumber = 165;
  const totalImages = endNumber - startNumber + 1;
  
  // 3. 규칙적인 이름의 파일 목록 자동 생성
  const autoGeneratedFiles = [];
  for (let i = 0; i < totalImages; i++) {
    const fileNumber = startNumber + i;
    const fileName = `${imagePath}${baseName}${fileNumber}${extension}`;
    autoGeneratedFiles.push(fileName);
  }

  // 4. 수동 및 자동 목록을 합쳐 최종 이미지 목록 완성
  const imageFiles = [...manualFiles, ...autoGeneratedFiles];

  // --- 변수 선언 및 초기화 ---
  let imageObjects = [];      // 이미지 정보({src, bounds})를 저장할 배열
  let currentImageIndex = 0;  // 현재 표시 중인 이미지의 인덱스
  let x = 0;                  // 로고의 x 좌표
  let y = 0;                  // 로고의 y 좌표
  let dx = 2;                 // x축 이동 속도
  let dy = 2;                 // y축 이동 속도
  let logoWidth;              // 현재 로고의 너비
  let logoHeight;             // 현재 로고의 높이
  let screenWidth;            // 화면 너비
  let screenHeight;           // 화면 높이
  let animationStarted = false; // 애니메이션 루프 중복 실행 방지 플래그

  /**
   * 모바일 브라우저의 주소창 등으로 인한 뷰포트 높이 문제를 해결합니다.
   * 실제 보이는 영역의 높이를 CSS 변수(--app-height)로 설정합니다.
   */
  const setRealViewportHeight = () => {
    const vh = window.innerHeight;
    document.documentElement.style.setProperty('--app-height', `${vh}px`);
  };

  /**
   * 이미지의 실제 콘텐츠 영역(투명 픽셀 제외)을 분석하여 경계 정보를 반환합니다.
   * @param {string} src - 분석할 이미지의 경로
   * @returns {Promise<object>} 이미지의 경계 정보(bounds)와 원본 크기를 담은 Promise
   */
  function analyzeImageBounds(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = src;

      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        try {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
          let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;

          // 모든 픽셀을 순회하며 투명하지 않은(alpha > 0) 픽셀의 경계를 찾습니다.
          for (let y_ = 0; y_ < canvas.height; y_++) {
            for (let x_ = 0; x_ < canvas.width; x_++) {
              const alpha = imageData[(y_ * canvas.width + x_) * 4 + 3];
              if (alpha > 0) {
                if (x_ < minX) minX = x_;
                if (x_ > maxX) maxX = x_;
                if (y_ < minY) minY = y_;
                if (y_ > maxY) maxY = y_;
              }
            }
          }

          if (maxX > -1) { // 내용이 있는 이미지인 경우
            resolve({ minX, minY, width: maxX - minX + 1, height: maxY - minY + 1, naturalWidth: img.width, naturalHeight: img.height });
          } else { // 완전히 투명한 이미지인 경우
            resolve({ minX: 0, minY: 0, width: 0, height: 0, naturalWidth: img.width, naturalHeight: img.height });
          }
        } catch (e) { // CORS 정책 위반 등 캔버스 오류 발생 시
          console.error(`이미지 분석 실패(CORS): ${src}`, e);
          // 실패하더라도 기본값으로 resolve하여 전체 프로세스가 멈추지 않도록 합니다.
          resolve({ minX: 0, minY: 0, width: img.width, height: img.height, naturalWidth: img.width, naturalHeight: img.height });
        }
      };
      
      // 이미지 로드 자체에 실패한 경우(파일 없음 등) Promise를 reject 합니다.
      img.onerror = () => reject(new Error(`이미지 로드 실패: ${src}`));
    });
  }

  /**
   * 스크린세이버를 초기화하는 메인 함수 (비동기 처리)
   */
  async function initializeScreenSaver() {
    setRealViewportHeight();

    // 표시할 이미지가 없으면 실행 중단
    if (imageFiles.length === 0) {
      console.error("이미지 파일 목록이 비어있습니다.");
      dvdLogo.style.display = 'none'; return;
    }

    try {
      console.log("이미지 경계 분석 시작...");
      // 모든 이미지에 대해 경계 분석을 동시에(병렬로) 실행합니다.
      const analysisPromises = imageFiles.map(src => analyzeImageBounds(src).then(bounds => ({ src, bounds })));
      
      // Promise.allSettled를 사용해 일부 이미지가 로드 실패해도 전체가 중단되지 않도록 합니다.
      const results = await Promise.allSettled(analysisPromises);
      
      // 성공적으로 로드되고 분석된 이미지 정보만 필터링하여 저장합니다.
      imageObjects = results
        .filter(result => {
          if (result.status === 'rejected') console.warn(`이미지 로드 실패:`, result.reason.message);
          return result.status === 'fulfilled';
        })
        .map(result => result.value);
      
      console.log(`로드된 이미지: ${imageObjects.length}개`);

      // 최종적으로 사용 가능한 이미지가 하나도 없으면 실행 중단
      if (imageObjects.length === 0) {
        console.error("사용 가능한 이미지가 없습니다.");
        dvdLogo.style.display = 'none'; return;
      }
    } catch (error) {
      console.error("초기화 중 예상치 못한 오류 발생:", error);
      dvdLogo.style.display = 'none'; return;
    }

    // 화면 크기를 업데이트하고 첫 이미지를 설정합니다.
    updateScreenDimensions();
    changeImage(true); // isInitial=true로 첫 이미지를 랜덤하게 설정
    
    // 로고의 초기 위치를 화면 내 랜덤한 곳으로 지정합니다.
    x = Math.random() * (screenWidth - logoWidth);
    y = Math.random() * (screenHeight - logoHeight);
    dvdLogo.style.transform = `translate(${x}px, ${y}px)`;

    // (추가) 초기 이미지 로그 출력
    console.log(`초기 이미지: ${imageObjects[currentImageIndex].src}`);

    // 애니메이션 루프를 시작합니다.
    if (!animationStarted) {
      requestAnimationFrame(animate);
      animationStarted = true;
    }
  }

  /**
   * 화면 크기 변수를 업데이트하는 함수
   */
  function updateScreenDimensions() {
    screenWidth = document.documentElement.clientWidth;
    screenHeight = document.documentElement.clientHeight;
  }

  /**
   * 애니메이션 루프: 매 프레임마다 로고의 위치를 업데이트하고 충돌을 감지합니다.
   */
  function animate() {
    // 좌표 업데이트
    x += dx;
    y += dy;

    // 현재 이미지의 경계 정보(bounds)를 가져옵니다.
    const currentImage = imageObjects[currentImageIndex];
    const bounds = currentImage.bounds;
    
    // 렌더링된 로고 크기와 원본 이미지 크기의 비율을 계산합니다.
    const scaleX = logoWidth / bounds.naturalWidth;
    const scaleY = logoHeight / bounds.naturalHeight;

    // 실제 눈에 보이는 콘텐츠의 화면상 절대 좌표를 계산합니다.
    const visualLeft = x + (bounds.minX * scaleX);
    const visualRight = x + ((bounds.minX + bounds.width) * scaleX);
    const visualTop = y + (bounds.minY * scaleY);
    const visualBottom = y + ((bounds.minY + bounds.height) * scaleY);

    let hit = false;
    // 좌우 충돌 감지
    if (visualRight >= screenWidth || visualLeft <= 0) {
      dx *= -1; // 방향 반전
      hit = true;
      // 로고가 화면 밖으로 나가지 않도록 위치를 정확히 보정합니다.
      x = (visualRight >= screenWidth) ? screenWidth - ((bounds.minX + bounds.width) * scaleX) : -(bounds.minX * scaleX);
    }
    // 상하 충돌 감지
    if (visualBottom >= screenHeight || visualTop <= 0) {
      dy *= -1; // 방향 반전
      hit = true;
      // 위치 보정
      y = (visualBottom >= screenHeight) ? screenHeight - ((bounds.minY + bounds.height) * scaleY) : -(bounds.minY * scaleY);
    }
    
    // 벽에 부딪혔다면 이미지를 변경합니다.
    if (hit) {
      changeImage();
    }

    // 계산된 위치로 로고를 이동시킵니다.
    dvdLogo.style.transform = `translate(${x}px, ${y}px)`;
    // 다음 프레임에 animate 함수를 다시 호출하여 루프를 지속합니다.
    requestAnimationFrame(animate);
  }

  /**
   * 이미지를 랜덤으로 변경하고, 크기를 재계산하며, 투명 영역을 잘라냅니다.
   * @param {boolean} [isInitial=false] - 초기 설정 시 호출되었는지 여부
   */
  function changeImage(isInitial = false) {
    let newIndex;
    // 초기 호출 시에는 완전 랜덤, 그 외에는 이전과 다른 이미지를 선택합니다.
    if (isInitial) {
        newIndex = Math.floor(Math.random() * imageObjects.length);
    } else {
        if (imageObjects.length > 1) {
            do {
                newIndex = Math.floor(Math.random() * imageObjects.length);
            } while (newIndex === currentImageIndex);
        } else {
            newIndex = 0;
        }
    }
    currentImageIndex = newIndex;
    const { src, bounds } = imageObjects[currentImageIndex];
    dvdLogo.src = src;

    // 로고의 실제 너비와 높이를 계산하여 업데이트합니다.
    logoWidth = dvdLogo.offsetWidth; // 너비는 CSS에 의해 고정되어 있으므로 안정적으로 측정 가능
    logoHeight = (bounds.naturalHeight / bounds.naturalWidth) * logoWidth; // 높이는 원본 비율에 따라 직접 계산

    // clip-path를 이용해 투명 영역을 시각적으로 제거합니다.
    const top = (bounds.minY / bounds.naturalHeight) * 100;
    const right = ((bounds.naturalWidth - (bounds.minX + bounds.width)) / bounds.naturalWidth) * 100;
    const bottom = ((bounds.naturalHeight - (bounds.minY + bounds.height)) / bounds.naturalHeight) * 100;
    const left = (bounds.minX / bounds.naturalWidth) * 100;
    dvdLogo.style.clipPath = `inset(${top}% ${right}% ${bottom}% ${left}%)`;

    // 초기 설정이 아닐 때만 이미지 변경 로그를 출력합니다.
    if (!isInitial) {
        console.log(`이미지 변경: ${src}`);
    }
  }

  // --- 이벤트 리스너 ---
  // 브라우저 창 크기가 변경될 때 실행됩니다.
  window.addEventListener("resize", () => {
    setRealViewportHeight();
    updateScreenDimensions();
    
    // 현재 이미지 기준으로 로고의 너비와 높이를 다시 계산합니다.
    const { bounds } = imageObjects[currentImageIndex];
    logoWidth = dvdLogo.offsetWidth;
    logoHeight = (bounds.naturalHeight / bounds.naturalWidth) * logoWidth;
    
    // 로고가 화면 밖으로 나가지 않도록 위치를 보정합니다.
    x = Math.max(0, Math.min(x, screenWidth - logoWidth));
    y = Math.max(0, Math.min(y, screenHeight - logoHeight));
    dvdLogo.style.transform = `translate(${x}px, ${y}px)`;
  });

  // --- 스크린 세이버 시작 ---
  initializeScreenSaver();
});